// --------------------------------------------------------------------------------------------------------------------
const removeEmptyValues = (object) => Object.fromEntries(Object.entries(object)
    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])
    .filter(Boolean));
// --------------------------------------------------------------------------------------------------------------------
const trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {
    var _a;
    const val = part[key];
    return [
        key,
        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : (_a = val) === null || _a === void 0 ? void 0 : _a.trim(),
    ];
}));
// --------------------------------------------------------------------------------------------------------------------
const parseArgumentPart = (text) => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: isOptional === '', f: formatterKeys };
};
// --------------------------------------------------------------------------------------------------------------------
const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
        values = key;
        key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
    if (nrOfEntries === 1) {
        return { k: key, r: zero };
    }
    if (nrOfEntries === 2) {
        return { k: key, o: zero, r: one };
    }
    if (nrOfEntries === 3) {
        return { k: key, z: zero, o: one, r: two };
    }
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
};
// --------------------------------------------------------------------------------------------------------------------
const REGEX_BRACKETS_SPLIT = /(\{(?:[^{}]+|\{(?:[^{}]+)*\})*\})/g;
const removeOuterBrackets = (text) => text.substring(1, text.length - 1);
const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
    .split(REGEX_BRACKETS_SPLIT)
    .map((part) => {
    if (!part.match(REGEX_BRACKETS_SPLIT)) {
        return part;
    }
    const content = removeOuterBrackets(part);
    if (content.startsWith('{')) {
        return parsePluralPart(removeOuterBrackets(content), lastKey);
    }
    const parsedPart = parseArgumentPart(content);
    lastKey = parsedPart.k || lastKey;
    !firstKey && (firstKey = lastKey);
    return parsedPart;
})
    .map((part) => {
    if (typeof part === 'string')
        return part;
    if (!part.k)
        part.k = firstKey || '0';
    const trimmed = trimAllValues(part);
    return optimize ? removeEmptyValues(trimmed) : trimmed;
});

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const isPluralPart = (part) => !!(part.o || part.r);
const REGEX_SWITCH_CASE = /^\{.*\}$/;
const applyFormatters = (formatters, formatterKeys, initialValue) => formatterKeys.reduce((value, formatterKey) => {
    var _a, _b;
    return (_b = (formatterKey.match(REGEX_SWITCH_CASE)
        ? (() => {
            var _a;
            const cases = Object.fromEntries(removeOuterBrackets(formatterKey)
                .split(',')
                .map((part) => part.split(':').map((value) => value.trim())));
            return (_a = cases[value]) !== null && _a !== void 0 ? _a : cases['*'];
        })()
        : (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, value))) !== null && _b !== void 0 ? _b : value;
}, initialValue);
const getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {
    switch (z && value == 0 ? 'zero' : pluralRules.select(value)) {
        case 'zero':
            return z;
        case 'one':
            return o;
        case 'two':
            return t;
        case 'few':
            return f;
        case 'many':
            return m;
        default:
            return r;
    }
};
const REGEX_PLURAL = /\?\?/g;
const applyArguments = (textParts, pluralRules, formatters, args) => textParts
    .map((part) => {
    if (typeof part === 'string') {
        return part;
    }
    const { k: key = '0', f: formatterKeys = [] } = part;
    const value = args[key];
    if (isPluralPart(part)) {
        return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL, value);
    }
    const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;
    return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();
})
    .join('');
const translate = (textParts, pluralRules, formatters, args) => {
    const firstArg = args[0];
    const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;
    const transformedArgs = (args.length === 1 && isObject ? firstArg : args);
    return applyArguments(textParts, pluralRules, formatters, transformedArgs);
};

// --------------------------------------------------------------------------------------------------------------------
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getFallbackProxy = (prefixKey) => new Proxy((prefixKey ? () => prefixKey : {}), {
    get: (_target, key) => getFallbackProxy(prefixKey ? `${prefixKey}.${key}` : key),
});

const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));

const getTextFromTranslationKey = (translations, key) => {
    var _a;
    key.split('.').forEach((k) => (translations = translations[k]));
    return (_a = translations) !== null && _a !== void 0 ? _a : key;
};
const getTranslateInstance = (locale, translations, formatters) => {
    const cache = {};
    const pluralRules = new Intl.PluralRules(locale);
    return (key, ...args) => translate(getPartsFromString(cache, getTextFromTranslationKey(translations, key)), pluralRules, formatters, args);
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function i18nObject(locale, translations, formatters = {}) {
    return createProxy(getTranslateInstance(locale, translations, formatters));
}
/* PROXY-START */
const createProxy = (fn, prefixKey, proxyObject = {}) => new Proxy((prefixKey ? fn.bind(null, prefixKey) : proxyObject), {
    get: (_target, key) => createProxy(fn, prefixKey ? `${prefixKey}.${key}` : key),
});
/* PROXY-CJS-END */

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const wrapProxy = (proxy) => new Proxy(proxy, {
    get: (_target, key) => !(typeof key !== 'string' || key.startsWith('__v_')) && _target[key],
});
const initI18nVuePlugin = (vueInject, vueRef, baseLocale = '', getTranslationForLocaleCallback, initFormattersCallback) => {
    const i18nKey = Symbol('typesafe-i18n');
    const typesafeI18n = () => vueInject(i18nKey);
    const getTranslationForLocale = getTranslationForLocaleCallback;
    const initFormatters = initFormattersCallback || (() => ({}));
    const i18nPlugin = {
        install: (app, locale) => {
            const LLref = vueRef(wrapProxy(getFallbackProxy()));
            const isLoadingLocaleRef = vueRef(true);
            const localeRef = vueRef(locale);
            const init = async (locale) => {
                isLoadingLocaleRef.value = true;
                const translations = await getTranslationForLocale(locale);
                const formatters = await initFormatters(locale);
                const LL = i18nObject(locale, translations, formatters);
                LLref.value = wrapProxy(LL);
                localeRef.value = locale;
                isLoadingLocaleRef.value = false;
            };
            init(locale || baseLocale);
            app.provide(i18nKey, {
                setLocale: init,
                isLoadingLocale: isLoadingLocaleRef,
                locale: localeRef,
                LL: LLref,
            });
        },
    };
    return { typesafeI18n, i18nPlugin };
};

export { initI18nVuePlugin };
//# sourceMappingURL=vue-plugin.mjs.map
