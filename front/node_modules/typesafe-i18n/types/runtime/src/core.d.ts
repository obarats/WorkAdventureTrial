import type { Part, PluralPart } from '../../parser/src/types';
declare type TranslationParts<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = {
    [key in keyof T]: Part[];
};
export declare type Cache<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = TranslationParts<T>;
export declare type TranslationKey<T extends BaseTranslation | BaseTranslation[] = BaseTranslation> = keyof T;
declare const localized: unique symbol;
export declare type LocalizedString = string & {
    readonly [localized]: unknown;
};
declare type BaseTranslationFunction = (...args: Arguments) => LocalizedString;
export declare type TranslationFunctions<T extends BaseTranslation | BaseTranslation[] | Readonly<BaseTranslation> | Readonly<BaseTranslation[]> = BaseTranslation> = {
    [key in keyof T]: T[key] extends string ? BaseTranslationFunction : T[key] extends Record<any, any> ? TranslationFunctions<T[key]> : never;
};
export declare type Locale = string;
export declare type Arguments = any[];
export declare type BaseTranslation = {
    [key: number]: string | BaseTranslation | BaseTranslation[] | Readonly<string> | Readonly<BaseTranslation> | Readonly<BaseTranslation[]>;
} | {
    [key: string]: string | BaseTranslation | BaseTranslation[] | Readonly<string> | Readonly<BaseTranslation> | Readonly<BaseTranslation[]>;
} | string[] | Readonly<string[]>;
export interface LocaleMapping {
    locale: string;
    translations: BaseTranslation | BaseTranslation[];
}
export declare type FormatterFunction<T = any, U = unknown> = (value: T) => U;
export declare type BaseFormatters = {
    [formatter: string]: FormatterFunction;
};
export declare const isPluralPart: (part: Part) => part is PluralPart;
export declare const translate: (textParts: Part[], pluralRules: Intl.PluralRules, formatters: BaseFormatters, args: Arguments) => LocalizedString;
export {};
