import { removeOuterBrackets } from '../../parser/src/index.mjs';
// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
export const isPluralPart = (part) => !!(part.o || part.r);
const REGEX_SWITCH_CASE = /^\{.*\}$/;
const applyFormatters = (formatters, formatterKeys, initialValue) => formatterKeys.reduce((value, formatterKey) => {
    var _a, _b;
    return (_b = (formatterKey.match(REGEX_SWITCH_CASE)
        ? (() => {
            var _a;
            const cases = Object.fromEntries(removeOuterBrackets(formatterKey)
                .split(',')
                .map((part) => part.split(':').map((value) => value.trim())));
            return (_a = cases[value]) !== null && _a !== void 0 ? _a : cases['*'];
        })()
        : (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, value))) !== null && _b !== void 0 ? _b : value;
}, initialValue);
const getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {
    switch (z && value == 0 ? 'zero' : pluralRules.select(value)) {
        case 'zero':
            return z;
        case 'one':
            return o;
        case 'two':
            return t;
        case 'few':
            return f;
        case 'many':
            return m;
        default:
            return r;
    }
};
const REGEX_PLURAL = /\?\?/g;
const applyArguments = (textParts, pluralRules, formatters, args) => textParts
    .map((part) => {
    if (typeof part === 'string') {
        return part;
    }
    const { k: key = '0', f: formatterKeys = [] } = part;
    const value = args[key];
    if (isPluralPart(part)) {
        return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL, value);
    }
    const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;
    return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();
})
    .join('');
export const translate = (textParts, pluralRules, formatters, args) => {
    const firstArg = args[0];
    const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;
    const transformedArgs = (args.length === 1 && isObject ? firstArg : args);
    return applyArguments(textParts, pluralRules, formatters, transformedArgs);
};
//# sourceMappingURL=core.js.map