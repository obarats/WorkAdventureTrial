"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRawText = exports.removeOuterBrackets = exports.trimAllValues = exports.removeEmptyValues = void 0;
// --------------------------------------------------------------------------------------------------------------------
const removeEmptyValues = (object) => Object.fromEntries(Object.entries(object)
    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])
    .filter(Boolean));
exports.removeEmptyValues = removeEmptyValues;
// --------------------------------------------------------------------------------------------------------------------
const trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {
    var _a;
    const val = part[key];
    return [
        key,
        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : (_a = val) === null || _a === void 0 ? void 0 : _a.trim(),
    ];
}));
exports.trimAllValues = trimAllValues;
// --------------------------------------------------------------------------------------------------------------------
const parseArgumentPart = (text) => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: isOptional === '', f: formatterKeys };
};
// --------------------------------------------------------------------------------------------------------------------
const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
        values = key;
        key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
    if (nrOfEntries === 1) {
        return { k: key, r: zero };
    }
    if (nrOfEntries === 2) {
        return { k: key, o: zero, r: one };
    }
    if (nrOfEntries === 3) {
        return { k: key, z: zero, o: one, r: two };
    }
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
};
// --------------------------------------------------------------------------------------------------------------------
const REGEX_BRACKETS_SPLIT = /(\{(?:[^{}]+|\{(?:[^{}]+)*\})*\})/g;
const removeOuterBrackets = (text) => text.substring(1, text.length - 1);
exports.removeOuterBrackets = removeOuterBrackets;
const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
    .split(REGEX_BRACKETS_SPLIT)
    .map((part) => {
    if (!part.match(REGEX_BRACKETS_SPLIT)) {
        return part;
    }
    const content = (0, exports.removeOuterBrackets)(part);
    if (content.startsWith('{')) {
        return parsePluralPart((0, exports.removeOuterBrackets)(content), lastKey);
    }
    const parsedPart = parseArgumentPart(content);
    lastKey = parsedPart.k || lastKey;
    !firstKey && (firstKey = lastKey);
    return parsedPart;
})
    .map((part) => {
    if (typeof part === 'string')
        return part;
    if (!part.k)
        part.k = firstKey || '0';
    const trimmed = (0, exports.trimAllValues)(part);
    return optimize ? (0, exports.removeEmptyValues)(trimmed) : trimmed;
});
exports.parseRawText = parseRawText;
//# sourceMappingURL=index.js.map