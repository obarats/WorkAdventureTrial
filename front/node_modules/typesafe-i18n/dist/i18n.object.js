(function () {
    'use strict';

    // --------------------------------------------------------------------------------------------------------------------
    const removeEmptyValues = (object) => Object.fromEntries(Object.entries(object)
        .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])
        .filter(Boolean));
    // --------------------------------------------------------------------------------------------------------------------
    const trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {
        var _a;
        const val = part[key];
        return [
            key,
            Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : (_a = val) === null || _a === void 0 ? void 0 : _a.trim(),
        ];
    }));
    // --------------------------------------------------------------------------------------------------------------------
    const parseArgumentPart = (text) => {
        const [keyPart = '', ...formatterKeys] = text.split('|');
        const [keyWithoutType = '', type] = keyPart.split(':');
        const [key, isOptional] = keyWithoutType.split('?');
        return { k: key, i: type, n: isOptional === '', f: formatterKeys };
    };
    // --------------------------------------------------------------------------------------------------------------------
    const parsePluralPart = (content, lastAccessor) => {
        let [key, values] = content.split(':');
        if (!values) {
            values = key;
            key = lastAccessor;
        }
        const entries = values.split('|');
        const [zero, one, two, few, many, rest] = entries;
        const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
        if (nrOfEntries === 1) {
            return { k: key, r: zero };
        }
        if (nrOfEntries === 2) {
            return { k: key, o: zero, r: one };
        }
        if (nrOfEntries === 3) {
            return { k: key, z: zero, o: one, r: two };
        }
        return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
    };
    // --------------------------------------------------------------------------------------------------------------------
    const REGEX_BRACKETS_SPLIT = /(\{(?:[^{}]+|\{(?:[^{}]+)*\})*\})/g;
    const removeOuterBrackets = (text) => text.substring(1, text.length - 1);
    const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
        .split(REGEX_BRACKETS_SPLIT)
        .map((part) => {
        if (!part.match(REGEX_BRACKETS_SPLIT)) {
            return part;
        }
        const content = removeOuterBrackets(part);
        if (content.startsWith('{')) {
            return parsePluralPart(removeOuterBrackets(content), lastKey);
        }
        const parsedPart = parseArgumentPart(content);
        lastKey = parsedPart.k || lastKey;
        !firstKey && (firstKey = lastKey);
        return parsedPart;
    })
        .map((part) => {
        if (typeof part === 'string')
            return part;
        if (!part.k)
            part.k = firstKey || '0';
        const trimmed = trimAllValues(part);
        return optimize ? removeEmptyValues(trimmed) : trimmed;
    });

    // --------------------------------------------------------------------------------------------------------------------
    // implementation -----------------------------------------------------------------------------------------------------
    // --------------------------------------------------------------------------------------------------------------------
    const isPluralPart = (part) => !!(part.o || part.r);
    const REGEX_SWITCH_CASE = /^\{.*\}$/;
    const applyFormatters = (formatters, formatterKeys, initialValue) => formatterKeys.reduce((value, formatterKey) => {
        var _a, _b;
        return (_b = (formatterKey.match(REGEX_SWITCH_CASE)
            ? (() => {
                var _a;
                const cases = Object.fromEntries(removeOuterBrackets(formatterKey)
                    .split(',')
                    .map((part) => part.split(':').map((value) => value.trim())));
                return (_a = cases[value]) !== null && _a !== void 0 ? _a : cases['*'];
            })()
            : (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, value))) !== null && _b !== void 0 ? _b : value;
    }, initialValue);
    const getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {
        switch (z && value == 0 ? 'zero' : pluralRules.select(value)) {
            case 'zero':
                return z;
            case 'one':
                return o;
            case 'two':
                return t;
            case 'few':
                return f;
            case 'many':
                return m;
            default:
                return r;
        }
    };
    const REGEX_PLURAL = /\?\?/g;
    const applyArguments = (textParts, pluralRules, formatters, args) => textParts
        .map((part) => {
        if (typeof part === 'string') {
            return part;
        }
        const { k: key = '0', f: formatterKeys = [] } = part;
        const value = args[key];
        if (isPluralPart(part)) {
            return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL, value);
        }
        const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;
        return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();
    })
        .join('');
    const translate = (textParts, pluralRules, formatters, args) => {
        const firstArg = args[0];
        const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;
        const transformedArgs = (args.length === 1 && isObject ? firstArg : args);
        return applyArguments(textParts, pluralRules, formatters, transformedArgs);
    };

    const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));

    const getTextFromTranslationKey = (translations, key) => {
        var _a;
        key.split('.').forEach((k) => (translations = translations[k]));
        return (_a = translations) !== null && _a !== void 0 ? _a : key;
    };
    const getTranslateInstance = (locale, translations, formatters) => {
        const cache = {};
        const pluralRules = new Intl.PluralRules(locale);
        return (key, ...args) => translate(getPartsFromString(cache, getTextFromTranslationKey(translations, key)), pluralRules, formatters, args);
    };
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    function i18nObject(locale, translations, formatters = {}) {
        return createProxy(getTranslateInstance(locale, translations, formatters));
    }
    /* PROXY-START */
    const createProxy = (fn, prefixKey, proxyObject = {}) => new Proxy((prefixKey ? fn.bind(null, prefixKey) : proxyObject), {
        get: (_target, key) => createProxy(fn, prefixKey ? `${prefixKey}.${key}` : key),
    });
    /* PROXY-CJS-END */

    //@ts-ignore
    window.i18nObject = i18nObject;

})();
//# sourceMappingURL=i18n.object.js.map
